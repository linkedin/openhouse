---
title: Getting Started
tags:
  - Spark
  - Hadoop
  - Docker
  - OpenHouse
  - Iceberg
  - Azure
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
    <TabItem value="s3" label="S3" default>
# OpenHouse with Spark & S3

In this guide, we will quickly set up a running environment and experiment with some simple SQL commands. Our
environment will include all the core OpenHouse services such as [Catalog Service](./intro.md#catalog-service),
[House Table service](./intro.md#house-table-service) and [others](./intro.md#control-plane-for-tables),
[a Spark 3.1 engine](https://spark.apache.org/releases/spark-release-3-1-1.html) and
also [MinIO S3 Instance](https://min.io/docs/minio/container/index.html).
In this walkthrough, we will create some tables on OpenHouse, insert data in them and query the data.
For more information on various docker environments and how to set them up
please see the [SETUP.md](https://github.com/linkedin/openhouse/blob/main/SETUP.md) guide.

In the consecutive optional section, you can learn more about some simple GRANT REVOKE commands and how
OpenHouse manages access control.

### Prerequisites
- [Docker CLI](https://docs.docker.com/get-docker/)
- [Docker Compose CLI](https://github.com/docker/compose-cli/blob/main/INSTALL.md)

## Create and write to OpenHouse Tables
### Get environment ready
First, clone [OpenHouse github repository](https://github.com/linkedin/openhouse) and
run `./gradlew build` command at the root directory. After the command succeeds you should see `BUILD SUCCESSFUL`
message.

```shell
openhouse$main>  ./gradlew build
```

Execute `docker compose -f infra/recipes/docker-compose/oh-s3-spark/docker-compose.yml up -d --build` command to
bring up docker containers for OpenHouse services, Spark and S3.

### Run SQL commands
Let us execute some basic SQL commands to create table, add data and query data.

First login to the driver node and start the spark-shell.
```shell
oh-hadoop-spark$main>  docker exec -it local.spark-master /bin/bash

openhouse@0a9ed5853291:/opt/spark$  bin/spark-shell --packages org.apache.iceberg:iceberg-spark-runtime-3.1_2.12:1.2.0,software.amazon.awssdk:bundle:2.20.18,software.amazon.awssdk:url-connection-client:2.20.18   \
--jars openhouse-spark-runtime_2.12-*-all.jar  \
--conf spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions,com.linkedin.openhouse.spark.extensions.OpenhouseSparkSessionExtensions   \
--conf spark.sql.catalog.openhouse=org.apache.iceberg.spark.SparkCatalog   \
--conf spark.sql.catalog.openhouse.catalog-impl=com.linkedin.openhouse.spark.OpenHouseCatalog     \
--conf spark.sql.catalog.openhouse.io-impl=org.apache.iceberg.aws.s3.S3FileIO   \
--conf spark.sql.catalog.openhouse.s3.endpoint=http://minioS3:9000  \
--conf spark.sql.catalog.openhouse.s3.access-key-id=admin  \
--conf spark.sql.catalog.openhouse.s3.secret-access-key=password  \
--conf spark.sql.catalog.openhouse.s3.path-style-access=true  \
--conf spark.sql.catalog.openhouse.metrics-reporter-impl=com.linkedin.openhouse.javaclient.OpenHouseMetricsReporter    \
--conf spark.sql.catalog.openhouse.uri=http://openhouse-tables:8080   \
--conf spark.sql.catalog.openhouse.auth-token=$(cat /var/config/openhouse.token) \
--conf spark.sql.catalog.openhouse.cluster=LocalS3Cluster
```
:::note
the configuration `spark.sql.catalog.openhouse.uri=http://openhouse-tables:8080` points to the docker container
running the [OpenHouse Catalog Service](./intro.md#catalog-service).
:::
:::note
the configuration `spark.sql.catalog.openhouse.io-impl` is set to `org.apache.iceberg.aws.s3.S3FileIO` in order
enable IO operations on S3. Parameters for this connection is configured via the prefix `spark.sql.catalog.openhouse.s3.*`.
:::
:::note
you can access the MinIO UI at `http://localhost:9871` of your host machine and inspect the state of objects
created for your table. The username is `admin` and password is `password` for the MinIO docker setup.
:::

    </TabItem>
    <TabItem value="hdfs" label="HDFS">
# OpenHouse with Spark & HDFS

In this guide, we will quickly set up a running environment and experiment with some simple SQL commands. Our
environment will include all the core OpenHouse services such as [Catalog Service](./intro.md#catalog-service),
[House Table service](./intro.md#house-table-service) and [others](./intro.md#control-plane-for-tables),
[a Spark 3.1 engine](https://spark.apache.org/releases/spark-release-3-1-1.html) and
also [HDFS namenode and datanode](https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html#NameNode+and+DataNodes).
In this walkthrough, we will create some tables on OpenHouse, insert data in them and query the data.
For more information on various docker environments and how to set them up
please see the [SETUP.md](https://github.com/linkedin/openhouse/blob/main/SETUP.md) guide.

In the consecutive optional section, you can learn more about some simple GRANT REVOKE commands and how
OpenHouse manages access control.

### Prerequisites
- [Docker CLI](https://docs.docker.com/get-docker/)
- [Docker Compose CLI](https://github.com/docker/compose-cli/blob/main/INSTALL.md)

## Create and write to OpenHouse Tables
### Get environment ready
First, clone [OpenHouse github repository](https://github.com/linkedin/openhouse) and
run `./gradlew build` command at the root directory. After the command succeeds you should see `BUILD SUCCESSFUL`
message.

```shell
openhouse$main>  ./gradlew build
```

Execute `docker compose -f infra/recipes/docker-compose/oh-hadoop-spark/docker-compose.yml up -d --build` command to
bring up docker containers for OpenHouse services, Spark and HDFS.

### Run SQL commands
Let us execute some basic SQL commands to create table, add data and query data.

First login to the driver node and start the spark-shell.
```shell
oh-hadoop-spark$main>  docker exec -it local.spark-master /bin/bash

openhouse@0a9ed5853291:/opt/spark$  bin/spark-shell --packages org.apache.iceberg:iceberg-spark-runtime-3.1_2.12:1.2.0   \
--jars openhouse-spark-runtime_2.12-*-all.jar  \
--conf spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions,com.linkedin.openhouse.spark.extensions.OpenhouseSparkSessionExtensions   \
--conf spark.sql.catalog.openhouse=org.apache.iceberg.spark.SparkCatalog   \
--conf spark.sql.catalog.openhouse.catalog-impl=com.linkedin.openhouse.spark.OpenHouseCatalog     \
--conf spark.sql.catalog.openhouse.metrics-reporter-impl=com.linkedin.openhouse.javaclient.OpenHouseMetricsReporter    \
--conf spark.sql.catalog.openhouse.uri=http://openhouse-tables:8080   \
--conf spark.sql.catalog.openhouse.auth-token=$(cat /var/config/openhouse.token) \
--conf spark.sql.catalog.openhouse.cluster=LocalHadoopCluster
```
:::note
the configuration `spark.sql.catalog.openhouse.uri=http://openhouse-tables:8080` points to the docker container
running the [OpenHouse Catalog Service](./intro.md#catalog-service).
:::
    </TabItem>
    <TabItem  value="azure" label="Azure">
# OpenHouse with Spark & Azure

In this guide, we will set up a running sandbox environment and experiment with some simple SQL commands. Our
environment includes the both [Catalog Service](./intro.md#catalog-service) and [House Table Service](./intro.md#house-table-service).
It also utilizes [a Spark 3.1 engine](https://spark.apache.org/releases/spark-release-3-1-1.html) and many
Azure services provisioned with [Terraform](https://developer.hashicorp.com/terraform?ajs_aid=a460286e-8e8f-4072-aa29-09a063308053&product_intent=terraform).
In this walkthrough, we will spin up this sandbox environment and deploy the OpenHouse services. Then, we will
create some tables, insert data in them, and query the data. For more information on the sandbox setup, checkout the 
[README.md](https://github.com/linkedin/openhouse/blob/main/infra/recipes/terraform/azure/environments/sandbox/README.md) file.

In the consecutive optional section, you can learn more about some simple GRANT REVOKE commands and how
OpenHouse manages access control.

### Prerequisites
- [Docker CLI](https://docs.docker.com/get-docker/)
- [Docker Compose CLI](https://github.com/docker/compose-cli/blob/main/INSTALL.md)
- [Azure CLI](https://learn.microsoft.com/en-us/cli/azure/)
- [Terraform CLI](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli)

## Deployment
### Step 1
Clone [OpenHouse github repository](https://github.com/linkedin/openhouse) and
run `./gradlew build` command at the root directory. After the command succeeds you should see `BUILD SUCCESSFUL`
message.

```shell
openhouse$main>  ./gradlew build
```

### Step 2
Setup an Azure account and create/choose a subscription. Run `az login` to login to your Azure account and subscription from the terminal.

### Step 3
Navigate into the container environment, and initialize and apply the Terraform configuration:
```shell
cd infra/recipes/terraform/azure/environments/container
terraform init
terraform apply
```

### Step 4
Navigate into the sandbox environment, and initialize and apply the Terraform configuration:
```shell
cd ../sandbox
terraform init
terraform apply
```

### Step 5
Start the docker containers for the Spark shell:
```shell
docker compose -f infra/recipes/docker-compose/spark-only/docker-compose.yml up -d --build
```
### Run SQL commands
Start the Spark shell by running
```shell
./scripts/spark-shell.sh
```
When prompted, type "Y".

    </TabItem>
</Tabs>


Once the spark-shell is up, we run the following command to create a simple table.

```sql
scala>  spark.sql("CREATE TABLE openhouse.db.tb (ts timestamp, data string) PARTITIONED BY (days(ts))")
```

Run a `SHOW TABLES` command to confirm the table that we just created!

```sql

scala> spark.sql("SHOW TABLES IN openhouse.db").show

+---------+---------+
|namespace|tableName|
+---------+---------+
| db      |       tb|
+---------+---------+

```

Great! We have created our first table. Now, let us put some data in it and retrieve it.

```sql

scala>  spark.sql("""
INSERT INTO TABLE openhouse.db.tb VALUES
   (current_timestamp(), 'today'),
   (date_sub(CAST(current_timestamp() as DATE), 30), 'today-30d')
 """)

scala> spark.sql("SELECT * FROM openhouse.db.tb").show

+--------------------+---------+
|                  ts|     data|
+--------------------+---------+
|2024-03-22 19:39:...|    today|
| 2024-02-21 00:00:00|today-30d|
+--------------------+---------+

```

Looks great! We just added some data to OpenHouse and queried the data using Spark SQL.

To find out more about other SQL commands that OH supports, please visit the [SQL User Guide](./User%20Guide/Catalog/SQL.md).


## (Optional) Control access to Tables
We will continue with the same environment and the table (ie db.table) as before for this section.

You might have seen the parameter `spark.sql.catalog.openhouse.auth-token=$(cat /var/config/openhouse.token)` when you
launched the sparkshell. This parameter sets up the client with your user token.

As you did before, start the spark-shell and run the following SQL command to make it fail.
```SQL
scala> spark.sql("GRANT SELECT ON TABLE openhouse.db.tb TO user_1").show

java.lang.IllegalArgumentException: 400 , {"status":"BAD_REQUEST","error":"Bad Request","message":"db.tb2 is not a shared table","stacktrace":null,"cause":"Not Available"}
```
This error means the table is not sharable. **In OpenHouse, tables are private by default**. You can share them by
running the SQL command:
```SQL
scala> spark.sql("ALTER TABLE openhouse.db.tb SET POLICY ( SHARING=true )")
```

In order to check the ACLs for this table, run:
```SQL

scala> spark.sql("SHOW GRANTS ON TABLE openhouse.db.tb2").show
+---------+---------+
|privilege|principal|
+---------+---------+
|   SELECT|   user_1|
+---------+---------+

```

You can also apply similar access control for database entity, please refer to the
[User Guide](./User%20Guide/Catalog/SQL.md#grant-revoke) to learn more.
